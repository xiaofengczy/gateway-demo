### 网关鉴权分享

### 1.springcloud gateway

#### (1)gateway与zuul对比

zuul:本质上是一个web servlet，基于servlet 2.5，使用阻塞api

gateway:使用netty进行网络通信，基于spring Framework5 ,Project Reactor和Spring Boot2之上，使用非阻塞api

- 压测工具(wrk)参数说明

| 参数名       | 说明                     |
| ------------ | ------------------------ |
| Latency      | 延迟                     |
| Req/Sec      | 吞吐量                   |
| Requests/sec | 平均每秒处理完成请求个数 |
| Transfer/sec | 平均每秒读取数据         |

- 测试项目

| 服务             | 端口 | 组件                 |
| ---------------- | ---- | -------------------- |
| provider-service | 6666 |                      |
| gateway-service  | 7777 | spring cloud gateway |
| zuul-service     | 8888 | netflix zuul         |

- 100并发空负载测试

gateway:

![1575972003885](/home/zycao/.config/Typora/typora-user-images/1575972003885.png)

zuul:

![1575972042234](/home/zycao/.config/Typora/typora-user-images/1575972042234.png)

- 500并发空负载测试 

gateway:

![1575972195047](/home/zycao/.config/Typora/typora-user-images/1575972195047.png)

zuul:

![1575972230012](/home/zycao/.config/Typora/typora-user-images/1575972230012.png)

- 100并发50ms业务处理测试

gateway:

![1576027560222](/home/zycao/.config/Typora/typora-user-images/1576027560222.png)

zuul:

![1576027594364](/home/zycao/.config/Typora/typora-user-images/1576027594364.png)

- 500并发50ms业务处理测试

gateway:

![1576027653855](/home/zycao/.config/Typora/typora-user-images/1576027653855.png)

zuul:

![1576027696373](/home/zycao/.config/Typora/typora-user-images/1576027696373.png)

**结论:**

​	(1) spring cloud gateway包含了所有zuul提供的功能

​	(2) spring cloud gateway是Spring官方支持，与Springcloud兼容性好

​	(3) 通过上述测试Springcloud性能优于zuul

#### (2)gateway相关

##### 2.1 **概念**

> 官方文档:`https://cloud.spring.io/spring-cloud-gateway/reference/html/`

1.springcloud gateway是基于`spring5`、`spring Boot2`和`Project Reactor`

2.springcloud gateway重点关注三部份:`Route`,`Predicate`,`Filter`

##### **2.2 运行原理**

![1576031680063](/home/zycao/.config/Typora/typora-user-images/1576031680063.png)

##### **2.3 gateway-demo**

沿用上述测试所有项目`gateway-service`和`provider-service`,外部请求经`gateway-service`透传至`provider-service`

(1)引入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```

(2)基本配置

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: provider
          uri: lb://provider-service
          predicates:
            - Path=/queryUser
          filters:
            - AddRequestHeader=context-user, {"userId":"1001"}
```



##### 2.4 **gateway 之 predict**

**根据路径匹配:**

```yaml
# path:根据路径匹配
spring:
  cloud:
    gateway:
      routes:
        - id: provider
          # 通过服务名实现路由
          uri: lb://provider-service
          # 通过ip:port实现路由
#          uri: http://localhost:6667
          # url路由
#          uri: http://admin.scm3.yunsom.space
          predicates:
            - Path=/provider/queryUser
          filters:
            - StripPrefix=1
  profiles: path
```

**根据Host匹配:**

```yaml
---
# 根据Host进行断言匹配
spring:
  cloud:
    gateway:
      routes:
        - id: provider
          uri: lb://provider-service
          predicates:
            - Host=admin.scm3.yunsom.space
          filters:
            - StripPrefix=1
  profiles: host-config
```



##### 2.5 **gateway 之 filter**

(1) 默认filter

> 常用filter:`StripPrefix`,`PrefixPath`,`Hystrix`,`RewritePath`

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: provider
          uri: lb://provider-service
          predicates:
            - Host=admin.scm3.yunsom.space
          filters:
            - StripPrefix=1
            - AddRequestParameter=name,tom
            - name: Hystrix
              args:
                name: fallbackcmd
                fallbackUri: forward:/fallback

hystrix:
  command:
    fallbackcmd:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 5000                
```

(2)Gateway Filter

- 继承`AbstractGatewayFilterFactory`

- 配置工厂类中`Config`

  ```java
  @Data
  public static class Config {
      public Config() {}
      private boolean enabled;
  }
  ```

- 将配置属性添加至属性集合中

  ```java
  @Override
  public List<String> shortcutFieldOrder() {
      return Arrays.asList("enabled");
  }
  ```

- 过滤逻辑

  ```java
  @Override
  public GatewayFilter apply(Config config) {
      return (exchange, chain) -> {
          if (!config.isEnabled()) {
              return chain.filter(exchange);
          }
          exchange.getAttributes().put("start_time", System.currentTimeMillis());
          return chain.filter(exchange).then(
              Mono.fromRunnable(() -> {
                  Long startTime = exchange.getAttribute("start_time");
                  if (startTime != null) {
                      StringBuilder sb = new StringBuilder(exchange.getRequest().getURI().getRawPath())
                          .append(": ")
                          .append(System.currentTimeMillis() - startTime)
                          .append("ms");
                      sb.append(" params:").append(exchange.getRequest().getQueryParams());
                      logger.info(sb.toString());
                  }
              })
          );
      };
  }
  ```

- 配置自定义过滤器,注意只取自定义过滤器前缀名，如`CustomGatewayFilterFactory`只取`Custom`

  ```yaml
  spring:
    cloud:
      gateway:
        routes:
          - id: provider
            # 通过服务名实现路由
            uri: lb://provider-service
            predicates:
              - Path=/provider/queryUser
            filters:
              - StripPrefix=1
              - name: Custom
                args:
                  enabled: true
             # 单个属性可采用如下配置
             # - Custom=true
  ```

(3)Global Filter

```java
@Component
public class GlobleGatewayFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String authorization = exchange.getRequest().getHeaders().getFirst("Authorization");
        if(StringUtils.isEmpty(authorization)){
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        List<String> authors = Arrays.asList(authorization.split(" "));
        if(StringUtils.isEmpty(authors)){
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```



##### 2.6 gateway 之 限流

gateway内置限流工厂`RequestRateLimiterGatewayFilterFactory`,具体限流方法,基于redis

(1) 书写限流逻辑,根据请求接口路径限流

> 返回路径即为需限流路径

```java
public class UriKeyResolver implements KeyResolver {

  @Override
  public Mono<String> resolve(ServerWebExchange exchange) {
    //返回路径即为需限流路径
    return Mono.just("/provider/queryUser");
  }
}
```

(2)spring加载`KeyResolver`

```java
@Bean
KeyResolver uriKeyResolver(){
    return new UriKeyResolver();
}
```

(3)配置文件配置限流filter

```yaml
filters:
    - name: RequestRateLimiter
    args:
    key-resolver: "#{@uriKeyResolver}"
    # 允许用户每秒处理多少个请求
    redis-rate-limiter.replenishRate: 1
    # 令牌桶容量，允许在一秒钟内完成的最大请求数
    redis-rate-limiter.burstCapacity: 5
```



#### (3)网关鉴权

##### 3.1 基于jwt(Json web Token)认证

jwt格式如下，共分为三个部份组成，以逗号分割,分为JWT头、有效载荷、签名三部分

![1576056653123](/home/zycao/.config/Typora/typora-user-images/1576056653123.png)

jwt解析出来如下:

```json
{
 alg: "HS256"
}.
{
 uid: 10415,
 dev: null,
 exp: 1576066549,
 uuid: "35f05860-bbec-4c52-a88b-207e3270d943",
 ttl: 10080,
 iat: 1576056439
}.
[signature]
```

**(1)JWT头**

```json
{
 "alg": "HS256",
 "type": "JWT"   
}
```

alg:表示签名算法，默认为`HMAC SHA256`写为`HS256`

type:表示表示令牌类型，统一都是JWT

**(2)有效载荷**

有效载荷是jwt主体内容，为json对象，包含用户相关信息,我们重点关注`uid`,`uuid`,`exp`

```json
{
 uid: 10415,
 dev: null,
 exp: 1576066549,
 uuid: "35f05860-bbec-4c52-a88b-207e3270d943",
 ttl: 10080,
 iat: 1576056439
}
```

**(3)签名哈希**

签名哈希是对`JWT头`,`有效载荷`两部份进行加密,同时需要指定密码`secret`,生成公式如下

```java
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret)
```

**(4)用法**

- 请求头中携带`Authorization: Bearer jwt-token`
- 校验jwt通过密钥解析，解析不成功，或失效则校验不通过，需重新登录，获取新的jwt-token
- 校验通过则在请求头中增加`context-user`用户相关信息，并请求下游服务!

##### 3.2 基于session-cookie认证

### 2.响应式编程(Reactor 3)

#### (1)Flux与Mono

​	Flux与Mono是数据流的发布者，可发布三种数据信号:"元素值"、"错误信息"、完成信息,错误信号与完成信号都是终止信号。

- Flux:表示包含0..N个元素的响应式序列

![1576120514914](/home/zycao/.config/Typora/typora-user-images/1576120514914.png)

- **发布元素值**

```java
@Test
  public void testFlux(){
    //直接创建
    Flux<Integer> just = Flux.just(1, 2, 3, 4, 5);
    just.subscribe(System.out::println);

    System.out.println("============================");

    //通过数组创建
    Flux<Integer> arrayFlux = Flux.fromArray(new Integer[]{11, 22, 33, 44, 55, 66});
    arrayFlux.subscribe(System.out::println);

    System.out.println("============================");
    //通过集合创建
    Flux<String> listFlux = Flux
        .fromIterable(Arrays.asList(new String[]{"jeck", "tom", "lilei"}));
    listFlux.subscribe(System.out::println);

    System.out.println("============================");
    //通过Stream创建
    Flux<Integer> streamFlux = Flux.fromStream(Arrays.stream(new Integer[]{123, 456, 789, 99}));
    streamFlux.subscribe(System.out::println);
  }
```

- **发布空数据完成信号**

```java
@Test
public void testFluxComplate(){
    Flux<Void> just = Flux.just();
    Flux<Object> empty = Flux.empty();
}
```

- **发布只有错误信号的数据流**

```java
@Test
public void testFluxError(){
    Flux<Object> errorFlux = Flux.error(new Exception("do error"));
}
```

- **订阅并触发数据流:subscribe()**

```java
//订阅并处理数据
subscribe();
//对正常数据和错误数据处理
subscribe(System.out::println,System.err::println);
//对完成信号做数据处理
subscribe(System.out::println,System.err::println,()->System.out.println("Complated!"));
```

- Mono:表示包含零/-个(0..1)元素结果

![1576120667802](/home/zycao/.config/Typora/typora-user-images/1576120667802.png)

#### (2)操作符

- map-元素映射为新元素

  ![1576122595983](/home/zycao/.config/Typora/typora-user-images/1576122595983.png)

  ```java
  @Test
  public void testMap(){
      Flux<Integer> just = Flux.range(1, 6);
      just.map(i->i*3).subscribe(System.out::println);
  }
  ```

- flatMap

  ```java
  @Test
  public void testFlatMap() {
      Flux<String> just = Flux.just("hello", "world");
      Flux<String> stringFlux1 = just
          .flatMap(f -> Flux.fromArray(f.split("\\s*")));
      stringFlux1.subscribe(System.out::println);
  }
  ```

- filter

  ```java
  @Test
  public void testFilter() {
      Flux<String> just = Flux.just("hello", "world");
      Flux<String> stringFlux = just.flatMap(f -> Flux.fromArray(f.split("\\s*")));
  
      //filter
      stringFlux.filter(s -> Objects.equals(s, "h"))
          .subscribe(System.out::println);
  
      //take
      stringFlux.take(2).subscribe(System.out::println);
  
      // skip
      stringFlux.skip(3).subscribe(System.out::println);
  }
  ```

- 错误处理

  (1) 出现错误直接处理

  ```java
  @Test
  public void testError(){
      Flux.range(1,6)
          .map(i->10/(i-4))
          .map(i->i*i)
          .subscribe(System.out::println,System.err::println);
  }
  ```

  (2)捕获异常并返回指定值`onErrorReturn()`

  ```java
  Flux.range(1,6)
      .map(i->10/(i-4))
      .onErrorReturn(200)
      .subscribe(System.out::println);
  ```

  (3)捕获异常并执行新的操作

  ```java
  @Test
  public void testErrorResume(){
      final Integer[] r = new Integer[1];
      Flux.range(1,6)
          .flatMap(k->getFromDB(r, k))
          .onErrorResume(e-> getFromCache(r[0]))
          .subscribe(System.out::println);
  }
  
  private Mono<Integer> getFromDB(Integer[] r, Integer k) {
      if(Objects.equals(k,3)){
          r[0] = k;
          return Mono.error(new BusinessException("查询用户异常"));
      }
      return Mono.just(k);
  }
  
  public Flux<Integer> getFromCache(Integer k){
      System.out.println("查询缓存用户");
      return Flux.just(k*3);
  }
  ```

  

  (4)捕获异常并抛出业务异常

  ```java
  @Test
  public void testErrorMap() {
      Flux.range(1, 6)
          .map(i->10/(i-3))
          .onErrorMap(o-> new TestException("query fail",o));
  }
  ```

  (5)只读取异常不做响应，异常继续传递

  ```java
  @Test
  public void testDoOnError() {
      Flux.range(1, 6)
          .map(i -> 10 / (i - 3))
          .doOnError(e -> logger.error("查询用户信息失败:{}", e))
          .onErr(6) finallyorMap(o->new TestException("查询失败",o))
          .subscribe(System.out::println,System.err::println);
  }
  ```



### 3.webflux

#### (1)基本操作



#### (2)整合mongo

#### (3)整合redis

#### (4)webclient调用远程服务



